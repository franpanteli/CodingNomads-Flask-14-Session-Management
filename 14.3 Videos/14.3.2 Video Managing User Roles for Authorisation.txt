-> assigning roles to new users  
   -> when a new user is created in a flask application, it's essential to assign them a role immediately. this ensures that users have appropriate access rights from the start  
   -> the user constructor (`__init__` method) is a logical place to assign roles since it is called when a user is created  
   -> role assignment process:  
     -> check if the user already has a role assigned. this can be done with a conditional check, for example: `if not self.role:`  
     -> if the user’s email matches a predefined admin email (e.g., `admin@example.com`), assign them the "admin" role  
       in python, you can compare the email like so:  
       ```python  
       if self.email == "admin@example.com":  
           self.role = "admin"  
       ```  
     -> admins must confirm their accounts before the admin role is fully activated. this can be handled by checking a `confirmed` attribute  
     -> if no special conditions are met, the user is assigned the default "user" role:  
       ```python  
       if not self.role:  
           self.role = "user"  
       ```  

-> helper methods for user permissions  
   -> it is crucial to have helper methods that simplify checking user permissions  
   -> `can_do_something`: a method to check if a user has a specific permission (e.g., accessing a resource or performing an action)  
     - example:  
       ```python  
       def can_do_something(self):  
           return "can_do_something" in self.permissions  
       ```  
   -> `is_administrator`: a method to check if the user is an administrator, useful for permission checks in routes  
     - example:  
       ```python  
       def is_administrator(self):  
           return self.role == "admin"  
       ```  
   -> anonymous users:  
     -> for users who haven’t logged in (anonymous users), you can set default methods that return `false` for permissions, as they don’t have any access  
     -> python code for an anonymous user might look like this:  
       ```python  
       class AnonymousUser:  
           def is_administrator(self):  
               return False  
           def can_do_something(self):  
               return False  
       ```  

-> handling anonymous users  
   -> after defining the anonymous user class, you need to integrate it with flask-login’s `AnonymousUserMixin` to ensure proper handling within the login manager  
   -> example of integrating with flask-login:  
     ```python  
     from flask_login import AnonymousUserMixin  
     
     class AnonymousUser(AnonymousUserMixin):  
         def is_administrator(self):  
             return False  
         def can_do_something(self):  
             return False  
     ```  
   -> you then need to let flask-login know about the new anonymous user class by setting it in the login manager:  
     ```python  
     login_manager.anonymous_user = AnonymousUser  
     ```  

-> using decorators for access control  
   -> flask provides built-in decorators such as `@login_required` to enforce authentication. however, custom decorators are useful for more granular control over who can access specific pages  
   -> custom decorators:  
     -> to restrict access based on permissions, you can create a custom decorator  
       example of a permission-based decorator:  
       ```python  
       from functools import wraps  
       from flask import abort  
       
       def permission_required(permission):  
           def decorator(func):  
               @wraps(func)  
               def wrapper(*args, **kwargs):  
                   if not current_user.can(permission):  
                       abort(403)  # forbidden error  
                   return func(*args, **kwargs)  
               return wrapper  
           return decorator  
       ```  
     -> this decorator can be used on routes that require a specific permission to access  
     -> for convenience, create an `@admin_required` decorator that checks if the user is an admin:  
       ```python  
       def admin_required(func):  
           return permission_required('admin')(func)  
       ```  

-> blueprints and route protection  
   -> in a flask application with blueprints, you can import your decorators and apply them to specific routes in your view functions (`views.py`)  
   -> example of applying `@admin_required` and `@login_required` decorators to restrict access to an admin-only route:  
     ```python  
     from flask_login import login_required  
     from yourapp import admin_required  
     
     @app.route('/admin')  
     @login_required  
     @admin_required  
     def admin_panel():  
         return render_template('admin_panel.html')  
     ```  
   -> note: decorators are applied in the order in which they are listed. the `@admin_required` decorator should come after `@login_required` to ensure the user is authenticated before checking if they are an admin  

-> testing permissions  
   -> testing route access control:  
     -> when logged in as a regular user, trying to access the admin route will result in a 403 forbidden error  
     -> example of handling this error:  
       ```python  
       @app.errorhandler(403)  
       def forbidden(error):  
           return render_template('403.html'), 403  
       ```  
     -> when logged in as an admin, access to the route will be allowed. this can be tested by logging in as an admin and visiting the route  

-> working with permissions in templates  
   -> to make permissions easily accessible in flask templates and view functions, you can inject the permissions class into the flask context  
   -> flask’s `g` object or `current_user` from `flask_login` can be used to provide the permissions object to templates  
     example of injecting permissions into a template:  
     ```python  
     @app.context_processor  
     def inject_permissions():  
         return dict(can_do_something=current_user.can_do_something())  
     ```  
   -> this way, permissions are available in all templates without the need to import them explicitly in each view or template  
   -> in the template, you can now check permissions directly:  
     ```html  
     {% if can_do_something %}  
         <p>You can perform this action!</p>  
     {% else %}  
         <p>You do not have permission to perform this action</p>  
     {% endif %}  
