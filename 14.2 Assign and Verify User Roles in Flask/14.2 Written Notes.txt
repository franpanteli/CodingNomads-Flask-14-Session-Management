-> introduction to user roles in flask  
    -> this lesson explains how to assign and verify user roles in flask applications  
    -> you'll learn to assign roles when users are created and verify those roles to control user access  
    -> the focus is on making sure users only perform actions they are allowed to do, using roles and permissions  

-> role assignment  
    -> assigning roles should happen when a user is created, to avoid bugs later on  
    -> you can check the user's email during creation to assign them special roles like "administrator"  
    -> the role is assigned using a database query that filters by the user's email and compares it with the admin email  
    -> this ensures the correct role is given to each user based on predefined criteria  

-> role verification  
    -> helper methods are used to check if a user has certain permissions  
    -> these methods ensure users can access only the resources they are allowed to  
    -> you can create a `can()` method to check permissions, for example, checking if a user can moderate a comment or publish content  
    -> an `is_administrator()` method checks if a user has the "administrator" permission  
    -> custom classes can be created to handle permission checks for anonymous users, using flask-login's `AnonymousUserMixin`  

-> custom decorators for view functions  
    -> custom decorators are used to check user permissions before they can access a view function  
    -> the `permission_required()` decorator checks if the user has the necessary permission to view or interact with a resource  
    -> the `admin_required()` decorator specifically checks if a user is an administrator  
    -> decorators are stacked in a specific order, with the `login_required` decorator checking if the user is logged in first  
    -> once logged in, further decorators ensure that the user has the correct permissions to access certain pages  

-> applying custom decorators  
    -> when applying decorators to view functions, ensure the correct order is followed  
    -> for example, `@login_required` should come before `@admin_required`  
    -> this ensures the user is authenticated before their permissions are checked  
    -> using these decorators, you can easily restrict access to views based on user roles and permissions  

-> injecting permissions into templates  
    -> permissions can be injected into templates to control what parts of a page are visible to the user  
    -> this allows for more granular control over page content, showing or hiding elements based on the user's permissions  
    -> use the flask `@app.context_processor` decorator to inject the `Permission` class into templates globally  
    -> this makes it easier to check permissions directly within templates without needing to pass them manually  

-> unit tests for user roles  
    -> it's important to test your role assignment and verification logic to ensure it works correctly  
    -> unit tests should verify that roles are assigned properly when users are created  
    -> tests should also check that users can only access resources they are permitted to based on their roles  
    -> additionally, verify that default roles, such as "user", are automatically assigned when a new user is created  

-> final steps  
    -> don't forget to insert roles into the database and assign them to existing users  
    -> perform a database migration to apply these changes across your application  
    -> after completing role assignments and verification, you can proceed to develop user profile pages  

-> summary: how to assign a user role  
    -> assign roles when users are created to avoid bugs and ensure smooth role management  
    -> helper methods and decorators simplify the process of verifying user permissions  
    -> injecting permissions into templates makes it easier to control page content based on user roles  
    -> always test role assignment and permissions to ensure everything functions as expected  